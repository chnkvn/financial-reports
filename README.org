#+startup: overview
* TODO Tasks
** DONE Scrapping
CLOSED: [2024-02-12 Mon 17:18]
- Price
- Name
- ISIN
- Reference Index
- Variation
- Asset Type
- Currency
- Historical Prices
** DONE Visualization
CLOSED: [2024-02-12 Mon 17:19]
- Asset pie chart
- Summary table
- Historical chart

** Aggregation
- [ ] Normalize asset types
- [ ] BDD qté
** Metrics
- TRI
- % PV/MV
- PV/MV
- Invested amount
** Lecture fichier
- ISIN not mandatory /!\
- Compare each security name with the ones existing in ptf
* Get data
:properties:
:header-args:python: :tangle src/data_extraction.py
:end:
- Use boursorama.com website
- Better to use an API, but as it is a simple project, navigating the source code is the way because it is free.
** imports :ignore:

#+begin_src python
import json
import re
from datetime import datetime, date
from itertools import chain
from typing import Iterable

import requests
import streamlit as st
from attrs import define, field
from bs4 import BeautifulSoup
from bs4.element import Tag
from icecream import ic

DATE_FORMAT = '%Y-%m-%d'


def date_to_str(date:datetime)-> str:
    if isinstance(date, datetime):
        #return date.strftime(DATE_FORMAT)
        return str(date.date())
    return date
def replace_stringify_date_objects_iterable(iterable: Iterable) -> Iterable:
    if isinstance(iterable,dict):
        return {key: (date_to_str(iterable[key])
                      if isinstance(iterable[key],(datetime,date))
                      else iterable[key]) for key in iterable}
    else:
        iterable = [date_to_str(x) if isinstance(x, datetime) else x for x in iter()]
        if isinstance(iterable, tuple):
            return tuple(iterable)
        elif isinstance(iterable, set):
            return set(iterable)
        return iterable
                
@define
class Asset:
    asset: str
    isin: str
    symbol: str
    currency: str
    name:str
    latest: float = field(converter=float)
    variation: float
    tradeDate: str = field(repr=date_to_str)
    url: str
    referenceIndex: str 
    morningstarCategory: str
    assetsComposition: dict
    #sectors: list
    lastDividende: dict = field(repr=replace_stringify_date_objects_iterable)
    
    def __hash__(self):
        return hash(self.isin)
    
    def __eq__(self, other):
        if not isinstance(other, Asset):
            # only equality tests to other `structure` instances are supported
            return NotImplemented
        return self.isin == other.isin

    @classmethod
    def from_boursorama(cls, data:dict):

        return cls(
            data['asset'],
            data['isin'],
            data['symbol'],
            data['currency'],
            data['name'],
            data['latest'],
            data['variation'],
            data['tradeDate'],
            data['url'],
            data['referenceIndex'],
            data['morningstarCategory'],
            data['assetsComposition'],
            #data['sectors'],
            data['lastDividende'])
    
    
#+end_src
** Get relevant data
#+begin_src python
def unicode_escape(s:str) -> str:
    """Remove unicode sequences from a string s"""
    return s.encode('utf8').decode('unicode_escape')

def extract_chart_data(soup:BeautifulSoup, id_:str ) -> dict:
    """Extract amChartData key from source code"""
    try:
        # Find the id in source code
        portfolio = soup.find_all('div', id=id_)
        # Extract the tags, remove NavigableString objects
        tags = list(chain.from_iterable(unicode_escape(x.get_text()).strip().split('\n')
                                        for x in portfolio[0].parent.contents if isinstance(x, Tag)))
        am_chart_data = [tag for tag in tags if '"amChartData"' in tag].pop()
        # Extract content
        return json.loads('{'+re.search(r'"amChartData":\[\{"name":.+\]\}',
                                        am_chart_data).group())['amChartData']
    except IndexError as e:
        return None

@st.cache_data
def get_current_asset_data(asset:str) -> dict:
    """From an ISIN or a asset name, returns a dictionary containing:
    - its symbol on boursorama.com
    - the latest price of the eassety
    - its daily variation
    - its financial exchange place code
    - its trade Date
    - store the url in a new key"""
    if asset.startswith('https://'):
        r = requests.get(asset)
    else:
        asset = asset.replace(' ', '%20')
        r = requests.get(f'https://www.boursorama.com/recherche/{asset}/')
    url_split = r.url.split('/')
    soup = BeautifulSoup(json.dumps(r.content.decode("utf-8")), "lxml").body
    data = {}
    try:
        symbol = url_split[-2]
        relevant_tag = next(iter(soup.select(f'div[data-faceplate-symbol*="{symbol}"]')))
        name = relevant_tag.select('a[title*="Cours"]')[0].get_text().replace('\\n', '').strip()
        # Remove irrelevent starting characters, and complete the string if data-ist-init is a class
        data = json.loads(relevant_tag['data-ist-init'].replace('\\"', '')+'"}') if relevant_tag.has_attr('data-ist-init') else {}
        if len(data) == 0:
            date_ = relevant_tag.find_all('div', class_='\\"c-faceplate__real-time\\"')[0]
            data['symbol'] = symbol
            
            data['tradeDate'] = datetime.strptime(re.search(r'[0-3][0-9]/[01][0-9]/[0-9]{4}', date_.get_text()).group(),'%d/%m/%Y')
        else:
            
            data['tradeDate'] = datetime.strptime(data['tradeDate'], '%Y-%m-%d')
        data['variation'] = relevant_tag.select('span[c-instrument--variation]')[0].get_text()
        data['latest'] = relevant_tag.select('span[c-instrument--last]')[0].get_text().replace(' ', '')
        data['isin'] = relevant_tag.find_all('h2', class_='\\"c-faceplate__isin\\"')[0].get_text().split(' ')[0]

        data['asset'] = url_split[url_split.index('cours')-1] if 'bourse' in r.url else 'Actions'
        data['name'] = unicode_escape(name)
        data['url'] = r.url
        data['currency'] = relevant_tag.find_all('span', class_ = '\\"c-faceplate__price-currency\\"').pop().get_text().strip()
        map_attributes = {
            'indice de référence':'referenceIndex',
            'catégorie morningstar': 'morningstarCategory',
            'amChartData': 'AssetsComposition'
        }
        # Init entries with null values
        for v in map_attributes.values():
            data[v] = None
        if 'bourse' in r.url:
            additional_info = soup.find_all('p', class_='\\"c-list-info__heading')
            for i in additional_info:
                attr = map_attributes.get(unicode_escape(i.get_text()).strip().lower(), unicode_escape(i.get_text()).strip())
                for v in i.next_siblings:
                    v= unicode_escape(v.get_text()).strip()
                    if '?' in v or len(v)<1:
                        continue
                    elif data.get(attr, None) is None :
                        data[attr]  =  v
                    elif isinstance(data[attr], str):
                        data[attr] = [data[attr]] + [v]
                    else:
                        data[attr].append(v)

        # Composition
        url_split.insert(-2, 'composition')
        composition_request = requests.get('/'.join(url_split))
        if composition_request.status_code == 200:
            soup = BeautifulSoup(json.dumps(composition_request.content.decode("utf-8")), "lxml").body
            data['assetsComposition'] = extract_chart_data(soup,'\\"portfolio\\"' )
            #data['sectors'] = extract_chart_data(soup,'\\"sector\\"' )
        else:
            data['assetsComposition'] = [{"name": data['asset'], 'value': 100  }]
            #data['sectors'] = [{'name': unicode_escape([link for link in soup.select('a[c-list-info__value]')][0].get_text()),
             #                  'value':100}]
        last_dividende = soup.find_all('p', string=re.compile('dernier dividende'))
        data['lastDividende'] = {}
        if len(last_dividende) >1:
            amount = False
            for p_tag in last_dividende:
                for sibling in p_tag.next_siblings:
                    if isinstance(sibling, Tag) and sibling.name=='p':
                        if sibling.attrs['class'] in [['\\"c-list-info__value'], '\\"c-list-info__value']:
                            if not amount:
                                data['lastDividende']['amount'] = unicode_escape(sibling.get_text()).strip()
                                amount = True
                                continue
                            try:
                                data['lastDividende']['date'] = datetime.strptime(unicode_escape(sibling.get_text()).strip(), '%d.%m.%y')

                            except ValueError as e:
                                data['lastDividende']['date'] = unicode_escape(sibling.get_text()).strip()
                            
        data = {k:(v.strip() if isinstance(v, str) else v) for k,v in data.items()}
        ic(data)
        return data
    except StopIteration as e:
        raise ValueError('No asset found. Try with another name or the ISIN of your asset.')


def get_historical_data(bourso_ticker:str):
    req = requests.get(f'https://www.boursorama.com/bourse/action/graph/ws/GetTicksEOD?symbol={bourso_ticker}&length=7300&period=0')
    return req.json()['d']['QuoteTab']
#+end_src

** Main :ignore:
#+begin_src python
if __name__ == '__main__':
    air_liquide = ['air liquide', 'FR0000120073']
    lvmh = ['mc', 'lvmh', 'FR0000121014']
    items = {Asset.from_boursorama(get_current_asset_data(asset)) for asset in air_liquide+lvmh}
    ic(items, len(items))


#+end_src
* Tests :ignore:
#+begin_src python :tangle tests/tests_scraping.py :results output
import os
import sys
import time
import unittest
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))

from financial_reports.src.data_extraction import Asset, get_current_asset_data

sys.path.append(os.path.join(os.path.dirname(__file__), ".."))
class TestAsset(unittest.TestCase):
    def test_stock(self):
        """Stock: air liquide"""
        for search in ['air liquide', 'AI', 'FR0000120073']:
            with self.subTest(i=search):
                AirLiquide = Asset.from_boursorama(get_current_asset_data(search))
                self.assertEqual(AirLiquide.asset, 'stock')
                self.assertEqual(AirLiquide.isin,'FR0000120073')
                self.assertEqual(AirLiquide.currency,'EUR')
                self.assertEqual(AirLiquide.name,'AIR LIQUIDE')
                self.assertEqual(AirLiquide.symbol, '1rPAI')
                self.assertEqual(AirLiquide.url, 'https://www.boursorama.com/cours/1rPAI/')
                self.assertGreaterEqual(AirLiquide.latest, 0)
                self.assertIsNone(AirLiquide.referenceIndex)
                self.assertIsNone(AirLiquide.morningstarCategory)
            time.sleep(1)

    def test_tracker(self):
        """Tracker: cw8"""
        for search in ['LU1681043599', 'CW8']:
            with self.subTest(i=search):
                cw8 = Asset.from_boursorama(get_current_asset_data(search))
                self.assertEqual(cw8.asset, 'trackers')
                self.assertEqual(cw8.isin,'LU1681043599')
                self.assertEqual(cw8.currency,'EUR')
                self.assertEqual(cw8.name,'AMUNDI MSCI WORLD UCITS ETF - EUR')
                self.assertEqual(cw8.symbol, '1rTCW8')
                self.assertEqual(cw8.url, 'https://www.boursorama.com/bourse/trackers/cours/1rTCW8/')
                self.assertGreaterEqual(cw8.latest, 0)
                self.assertEqual(cw8.referenceIndex, 'MSCI World')
                self.assertEqual(cw8.morningstarCategory, 'Actions International Gdes Cap. Mixte')
            time.sleep(1)

    def test_opcvm(self):
        """OPCVM: Réserve Ecureuil C"""
        for search in ['FR0010177378']:
            with self.subTest(i=search):
                ecureuil = Asset.from_boursorama(get_current_asset_data(search))
                self.assertEqual(ecureuil.asset, 'opcvm')
                self.assertEqual(ecureuil.isin, 'FR0010177378')
                self.assertEqual(ecureuil.currency, 'EUR')
                self.assertEqual(ecureuil.name, 'Réserve Ecureuil C')
                self.assertEqual(ecureuil.symbol, 'MP-184677')
                self.assertEqual(ecureuil.url,'https://www.boursorama.com/bourse/opcvm/cours/MP-184677/' )
                self.assertGreaterEqual(ecureuil.latest, 0)
                self.assertEqual(ecureuil.morningstarCategory, 'Swap EONIA PEA')
                self.assertIsNone(ecureuil.referenceIndex)
            time.sleep(1)

        

if __name__ == '__main__':
    unittest.main()

#+end_src

#+RESULTS:

* Streamlit
:properties:
:header-args:python: :tangle app.py
:end:
** Imports, interface, data folders :ignore:
#+begin_src python
import os
import sys
import time
from datetime import date, datetime, timedelta
from itertools import chain
from pathlib import Path
from typing import Iterable

import duckdb
import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import srsly
import streamlit as st
from attrs import asdict
from icecream import ic

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from financial_reports.src.data_extraction import (DATE_FORMAT, Asset,
                                                   date_to_str,
                                                   get_current_asset_data,
                                                   get_historical_data)

st.set_page_config(
    page_title="Asset visualizer",
    layout="wide",
    initial_sidebar_state="expanded")
st.title('Asset visualizer')

# Create data/json, data/parquet if they do not exist
for save_path in ["data/jsonl", "data/db"]:
    Path(save_path).mkdir(parents=True, exist_ok=True)

ptf_name = st.text_input('Name of the portfolio (This name will be used the save and load your portfolio.)',
                         st.session_state.get('ptf_name', 'MyPortfolio'),
                         placeholder='MyPortfolio',
                         key='ptf_name')
jsonl_ptf_path = f"data/jsonl/{ptf_name}.jsonl"
csv_ptf_path = f"data/db/{ptf_name}.csv"
today = date.today()
dict_of_assets = {a['isin'] : Asset.from_boursorama(get_current_asset_data(a['url']))
                 for a in srsly.read_jsonl(jsonl_ptf_path)} if Path(jsonl_ptf_path).is_file() else {}

# Initialization
db_exists = Path(csv_ptf_path).is_file()

if not db_exists:
    operations =pd.DataFrame({column_name: [] for column_name in ['name', 'isin', 'date', 'operation', 'quantity', 'value']})
else:
    operations = pd.read_csv(csv_ptf_path)
    operations = duckdb.sql(f'''
    select row_number() over(order by date, isin, name) as id, * from operations ORDER BY id, date, name, isin DESC ''').df()

distinct_isins = set(chain.from_iterable(duckdb.sql("select distinct isin from operations").fetchall()))
dict_of_assets.update(
    {isin:Asset.from_boursorama(get_current_asset_data(isin))
     for isin in distinct_isins
      })

if 'name_isin' not in st.session_state:
    st.session_state['name_isin'] = sorted([(a.name, a.isin) for a in dict_of_assets.values()], key=lambda x: x[0])
#+end_src
** Functions :ignore:
#+begin_src python

def plot_piechart(data:Iterable, cat_name:str='name', value:str='value'):
    """Extract varible names and their values.
    Returns a pie chart."""
    categories = []
    values = []
    for d in data:
        categories.append(d[cat_name])
        values.append(d[value])
    fig = go.Figure(data=[go.Pie(labels=categories, values=values)])
    return fig

def ptf_piechart(iter_of_dicts:Iterable):
    d = {}
    for i,dict_ in enumerate(iter_of_dicts):
        d[dict_['name']] = d.get(dict_['name'], 0) + float(dict_['value'])
    [*categories], [*values] = list(zip(*d.items()))
    values = np.array(values)
    fig = go.Figure(data=[go.Pie(labels=categories, values=values/(i+1))])
    return fig

def convert_to_date(nb:int):
    init_date =datetime.strptime('1970-01-01', DATE_FORMAT)
    return str((init_date + timedelta(days=nb)).date())

def plot_historical_chart(df:pd.DataFrame, name:str, isin:str):
    fig = px.line(df, x="date", y="c", title=f'{name} - {isin}')
    return fig

    
#+end_src
** Sidebar :ignore:
#+begin_src python
with st.form("sidebar"):
    with st.sidebar:
        asset = st.text_input(
            "Enter an ISIN. You may also enter a name or a ticker, but you might get some errors.\nPrefilled with MC, the ticker of LVMH stock.",
            value = st.session_state.get('last_asset','MC'),
            placeholder = "ISIN, Ticker.",
            key='last_asset'
        )
        adding_to_portfolio = st.checkbox('Add to your portfolio', True)
        submitted = st.form_submit_button("Submit")
        if submitted:
            st.write(f"Asset: {asset}")
            asset_obj = Asset.from_boursorama(get_current_asset_data(asset))
            st.header(f"Name: {asset_obj.name}")
            asset_as_dict = asdict(asset_obj)
            asset_as_dict["tradeDate"] = date_to_str(asset_as_dict["tradeDate"])
            if len(asset_as_dict["lastDividende"]) > 0:
                asset_as_dict["lastDividende"]["date"] = date_to_str(
                    asset_as_dict["lastDividende"]["date"]
                        )
                st.dataframe(
                    asset_as_dict,
                    column_config={0: "property", 1: "value"},
                    use_container_width=True,
                )

            asset_comp, historic_chart = st.tabs(['Asset composition', 'Historical prices'])
            with asset_comp:
                st.subheader(f"Asset composition")
                asset_comp_chart = plot_piechart(
                    asset_as_dict["assetsComposition"], "name", "value"
                    )
                st.plotly_chart(asset_comp_chart, use_container_width=True)

            with historic_chart:
                st.subheader(f"Historical prices {asset_as_dict['currency']}")
                st.write('You can view the chart in full screen and zoom in the period by selecting the wanted period.')
                history = get_historical_data(asset_as_dict["symbol"])
                df = pd.DataFrame(history)
                df["date"] = df.d.apply(convert_to_date)
                st.plotly_chart(
                    plot_historical_chart(df, asset_as_dict["name"], asset_as_dict["isin"])
                    )

            

#+end_src
** Body
#+begin_src python

#details_col, operations_col = st.columns(2)
operations_col, details_col= st.tabs(["Portfolio Operations", "Portfolio details"])
            
with operations_col:
    st.subheader('Portfolio operations')
    st.dataframe(operations, hide_index=True)


    # Operation tabs
    add_row, del_row = st.tabs(['Add operation', 'Remove operation'])
    # Add operation
    with add_row:
        with st.empty().container():
            operation_type = st.selectbox(
                    "Operation type",
                    ("Buy", "Sell", "Dividend", "Split"),
                    index=None,
                    placeholder="Select your operation type.",
                    key='operation_type_add'
                )
            operation_date = st.date_input("Date operation", "today",
                                           format = "YYYY-MM-DD", key='operation_date_buy')
            operation_on_asset = st.selectbox("The asset to perform the operation.",
                                          st.session_state['name_isin'],
                                          index=None,
                                          placeholder = "Select the asset.",
                                          key='asset_operation_add')
            argA, argB = None, None
            if st.session_state.get('operation_type_add', None) not in ['Split', 'Interest']:
                
                if operation_type in ['Buy', 'Sell']:
                    if operation_type == 'Buy':
                        argB = st.number_input("Quantity",value= 1.0, min_value=0.001)
                        argA = st.number_input("Price", min_value=0.01)
                    else: #sell
                        try:
                            asset_operations = duckdb.sql(f"""select operation, sum(quantity) as sum_qty
                            from operations
                            where name='{st.session_state["asset_operation_add"][0]}' and isin='{st.session_state["asset_operation_add"][1]}'
                            group by operation""").fetchall()
                            asset_operations = {op: value for (op, value) in asset_operations}
                            argB = st.number_input("Quantity",
                                                   value=1.0,
                                                   min_value=0.0,
                                                   max_value=asset_operations.get('Buy', 0 ) - asset_operations.get('Sell', 0))
                            argA = st.number_input("Price", min_value=0.01)
                            
                        except Exception as e:
                            # Cannot sell assets we do not own.
                            st.write('You cannot sell assets you do not own.')
                            # Disable add operation button
                            st.session_state['invalid_operation'] =1
                elif operation_type == 'Dividend':

                    argA = st.number_input("Dividend value", min_value=0.01)
               
            
            elif st.session_state.get('operation_type_add', None) =='Split':
                argA =  st.text_input("Split ratio",
                                      placeholder = 'Enter the split ratio, e.g. "11:10" or "2:1"'
                                      )
                if argA:
                    # Check the ratio is valid
                    after, before = argA.strip().split(':')
                    if not after.isdecimal() or not before.isdecimal():
                        raise ValueError("You must enter a valid split ratio,"
                                             " two integer numbers separated by a colon(:).")
                    argA = int(after)/int(before)
            # Check all arguments are filled to enable add operation button
            if all([argA, operation_on_asset is not None,operation_type is not None]):
                st.session_state['invalid_operation'] = 0
            # Append operation to csv
            if st.button('Add operation', disabled=st.session_state.get('invalid_operation', 1)):
                operations.loc[len(operations.operation)] = {'name':operation_on_asset[0],
                                                             'isin':operation_on_asset[1],
                                                             'date':operation_date.isoformat(),
                                                             'operation':operation_type,
                                                             'quantity':argB,
                                                             'value':argA}
                operations.to_csv(csv_ptf_path,
                                  index=False,
                                  columns=[col for col in operations.columns
                                           if not col.startswith('id')])
                #elif operation_type in ['Dividend', 'Split']:
                
                #duckdb.sql(f'COPY operations TO {csv_ptf_path}')
                st.rerun()

    # Delete row                
    with del_row:
        with st.form('delete_row'):
            try:
                row_number = st.number_input("Row number", min_value=1, max_value = len(operations.operation),
                                            placeholder = 'Row number to remove' )
            except Exception as e:
                #st.write(e)
                st.write('Please add an operation before trying to remove one.')
            delete_row = st.form_submit_button('Delete row')
            if delete_row:
                 duckdb.sql(f"""
                 WITH row_nb_table AS (
                 select row_number() over(order by date, isin, name) as id,
                 ,* from '{csv_ptf_path}'
                 ORDER BY  date, name, isin DESC

                 )
                 Select
                 rnt.name,
                 rnt.isin,
                 rnt.date,
                 rnt.operation,
                 rnt.quantity,
                 rnt.value
                 from row_nb_table rnt
                 Left JOIN '{csv_ptf_path}'
                 using (isin, date, operation, quantity,value)
                 where rnt.id != {row_number}
                 """).write_csv(csv_ptf_path)
                 st.rerun()

                
## Portfolio tab
with details_col:
    if submitted and adding_to_portfolio:
        dict_of_assets[asset_obj.isin]= asset_obj

        srsly.write_jsonl(jsonl_ptf_path, [asdict(a) for a in dict_of_assets.values()])

    with st.expander('Followed assets'):
        ptf_df = pd.DataFrame(
            [
                {
                    k: v
                    for k, v in asdict(a).items()
                    if k
                    not in [
                        "tradeDate",
                        "assetsComposition",
                        "url",
                        "referenceIndex",
                        "morningstarCategory",
                    ]
                }
                for a in dict_of_assets.values()
            ]
        )

        ptf_df.insert(0, "in_ptf", True)
        with st.form("update_assets"):
            ptf_df = st.data_editor(
                ptf_df,
                column_config={
                    "in_ptf": st.column_config.CheckboxColumn(
                        "In portfolio?",
                        help="Select your current assets.",
                        default=True,
                    )
                },
                disabled=[column for column in ptf_df.columns if column != "in_ptf"],
                hide_index=True,
            )
            update_assets = st.form_submit_button("Update assets")
            if update_assets:
                keep_isin = duckdb.sql("""SELECT isin from ptf_df where in_ptf='True'""").fetchall()
                srsly.write_jsonl(
                    jsonl_ptf_path,
                    [
                        asdict(dict_of_assets[a])
                        for a in dict_of_assets
                        if a in set(chain.from_iterable(keep_isin))
                    ],
                )
                st.rerun()
    portfolio_summary = duckdb.sql("""
    
    """)
    st.dataframe(operations, hide_index=True)
    if len(dict_of_assets) > 0:
        total_assets_comp = chain.from_iterable(
            [a.assetsComposition for a in dict_of_assets.values()]
        )
        # total_sectors_comp = chain.from_iterable([a.sectors for a in dict_of_assets if a.sectors])
        ptf_asset_comp, ptf_sector_comp = st.columns(2)
        with ptf_asset_comp:
            st.subheader("Portfolio asset repartition")
            ptf_asset_comp_chart = ptf_piechart(total_assets_comp)
            st.plotly_chart(ptf_asset_comp_chart, use_container_width=True)
#+end_src

#+RESULTS:


* Next steps
- Add a way to configure data for SCPIs
