#+startup: overview

* Financial data
- Use boursorama.com website
- Better to use an API, but as it is a simple project, navigating the source code is the way because it is free.
** Code :noexport:
:properties:
:header-args:python: :tangle src/data_extraction.py
:end:
#+begin_src python
import json
import re
from datetime import date, datetime, timedelta
from itertools import chain
from typing import Iterable

import duckdb
import pandas as pd
import requests
import streamlit as st
from attrs import define, field
from bs4 import BeautifulSoup
from bs4.element import Tag

DATE_FORMAT = "%Y-%m-%d"
TODAY = date.today()
map_period_to_filter = {
    "inception": "",
    f"{TODAY.year-1}": f"where date >='{TODAY.year-1}-01-01' and date <'{TODAY.year}-01-01'",
    "ytd": f"where date >='{TODAY.year}-01-01' and date <'{TODAY.year+1}-01-01'",
    "1week": f"""WHERE date >= '{str(TODAY-timedelta(weeks=1))}'
    AND date <= '{str(TODAY)}' """,
    "1month": f"""WHERE date >= '{str(TODAY-timedelta(30))}'
    AND date <= '{str(TODAY)}' """,
    "3months": f"""WHERE date >= '{str(TODAY-timedelta(91))}'
    AND date <= '{str(TODAY)}' """,
    "6months": f"""WHERE date >= '{str(TODAY-timedelta(184))}'
    AND date <= '{str(TODAY)}' """,
    "1year": f"""WHERE date >= '{str(date(year=TODAY.year-1,month=TODAY.month, day=TODAY.day))}'
    AND date <= '{str(TODAY)}' """,
    "3years": f"""WHERE date >= '{str(date(year=TODAY.year-3,month=TODAY.month, day=TODAY.day))}'
    AND date <= '{str(TODAY)}' """,
    "5years": f"""WHERE date >= '{str(date(year=TODAY.year-5,month=TODAY.month, day=TODAY.day))}'
    AND date <= '{str(TODAY)}' """,
}


def date_to_str(date: datetime) -> str:
    if isinstance(date, datetime):
        # return date.strftime(DATE_FORMAT)
        return str(date.date())
    return date


def replace_stringify_date_objects_iterable(iterable: Iterable) -> Iterable:
    if isinstance(iterable, dict):
        return {
            key: (
                date_to_str(iterable[key])
                if isinstance(iterable[key], (datetime, date))
                else iterable[key]
            )
            for key in iterable
        }
    else:
        iterable = [date_to_str(x) if isinstance(x, datetime) else x for x in iter()]
        if isinstance(iterable, tuple):
            return tuple(iterable)
        elif isinstance(iterable, set):
            return set(iterable)
        return iterable


def compute_perf(df: pd.DataFrame):
    """Compute the performance of an asset given a dataframe"""
    min_value = duckdb.sql(
        """
    SELECT date, c from df
    where date = (select min(date) from df )
     """
    ).fetchall()[0]
    max_value = duckdb.sql(
        """
    SELECT date, c from df
    where date = (select max(date) from df)
     """
    ).fetchall()[0]
    return f"{100*((max_value[1]/min_value[1])-1):.2f}%"


@define
class Asset:
    """Create an instance of Asset object.
    An asset object has the following attributes:
    - asset (str): the type of asset e.g. stock
    - isin (str): the isin code of the asset
    - symbol (str): a symbol used to get the data using boursorama website
    - currency (str): the currency of the asset
    - name (str): the name of the asset
    - latest (float): the latest quotation price of the asset
    - variation (float): stock variation since the previous day
    - tradeDate (str): the last date of trade
    - url (str): the url used to scrap the asset
    - referenceIndex (str): the index of reference of the asset
    - morningstarCategory (str): the morningstar category associated to the asset
    - lastDividende (dict): a dict containing the date and the value of the last dividende
    - quotations: the historical quotations of the asset
    """
    asset: str
    isin: str
    symbol: str
    currency: str
    name: str
    latest: float = field(converter=float)
    variation: float
    tradeDate: str = field(repr=date_to_str)
    url: str
    referenceIndex: str
    morningstarCategory: str
    assetsComposition: dict
    # sectors: list
    lastDividende: dict = field(repr=replace_stringify_date_objects_iterable)
    _quotations: list = None

    def __hash__(self):
        return hash(self.isin)

    def __eq__(self, other):
        if not isinstance(other, Asset):
            # only equality tests to other `structure` instances are supported
            return NotImplemented
        return self.isin == other.isin

    @classmethod
    def from_boursorama(cls, data: dict):
        return cls(
            data["asset"],
            data["isin"],
            data["symbol"],
            data["currency"],
            data["name"],
            data["latest"],
            data["variation"],
            data["tradeDate"],
            data["url"],
            data["referenceIndex"],
            data["morningstarCategory"],
            data["assetsComposition"],
            # data['sectors'],
            data["lastDividende"],
        )

    @property
    def quotations(self, filter=map_period_to_filter):
        """Return quotations"""
        if self._quotations is None:
            historical_data_df = get_historical_data(self.symbol)
            # close prices : c
            # Create dataframes for each period and store them in a dict
            self._quotations = {
                period: duckdb.sql(
                    f"""
                select CAST(date AS DATE) date, c
                from historical_data_df
                {map_period_to_filter.get(period, '')}
                ORDER BY date"""
                ).df()
                for period in map_period_to_filter
            }

        return self._quotations


def unicode_escape(s: str) -> str:
    """Remove unicode sequences from a string s"""
    return s.encode("utf8").decode("unicode_escape")


def extract_chart_data(soup: BeautifulSoup, id_: str) -> dict:
    """Extract amChartData key from source code"""
    try:
        # Find the id in source code
        portfolio = soup.find_all("div", id=id_)
        # Extract the tags, remove NavigableString objects
        tags = list(
            chain.from_iterable(
                unicode_escape(x.get_text()).strip().split("\n")
                for x in portfolio[0].parent.contents
                if isinstance(x, Tag)
            )
        )
        am_chart_data = [tag for tag in tags if '"amChartData"' in tag].pop()
        # Extract content
        return json.loads(
            "{" + re.search(r'"amChartData":\[\{"name":.+\]\}', am_chart_data).group()
        )["amChartData"]
    except IndexError as e:
        print(e)
        return None


@st.cache_data
def get_current_asset_data(asset: str) -> dict:
    """From an ISIN or a asset name, returns a dictionary containing:
    - its symbol on boursorama.com
    - the latest price of the eassety
    - its daily variation
    - its financial exchange place code
    - its trade Date
    - store the url in a new key"""
    if asset.startswith("https://"):
        r = requests.get(asset)
    else:
        asset = asset.replace(" ", "%20")
        r = requests.get(f"https://www.boursorama.com/recherche/{asset}/")
    url_split = r.url.split("/")
    soup = BeautifulSoup(json.dumps(r.content.decode("utf-8")), "lxml").body
    data = {}
    try:
        symbol = url_split[-2]
        relevant_tag = next(
            iter(soup.select(f'div[data-faceplate-symbol*="{symbol}"]'))
        )
        name = (
            relevant_tag.select('a[title*="Cours"]')[0]
            .get_text()
            .replace("\\n", "")
            .strip()
        )
        # Remove irrelevent starting characters, and complete the string if data-ist-init is a class
        data = (
            json.loads(relevant_tag["data-ist-init"].replace('\\"', "") + '"}')
            if relevant_tag.has_attr("data-ist-init")
            else {}
        )
        if len(data) == 0:
            date_ = relevant_tag.find_all("div", class_='\\"c-faceplate__real-time\\"')[
                0
            ]
            data["symbol"] = symbol

            data["tradeDate"] = datetime.strptime(
                re.search(r"[0-3][0-9]/[01][0-9]/[0-9]{4}", date_.get_text()).group(),
                "%d/%m/%Y",
            )
        else:

            data["tradeDate"] = datetime.strptime(data["tradeDate"], "%Y-%m-%d")
        data["variation"] = relevant_tag.select("span[c-instrument--variation]")[
            0
        ].get_text()
        data["latest"] = (
            relevant_tag.select("span[c-instrument--last]")[0]
            .get_text()
            .replace(" ", "")
        )
        data["isin"] = (
            relevant_tag.find_all("h2", class_='\\"c-faceplate__isin\\"')[0]
            .get_text()
            .split(" ")[0]
        )

        data["asset"] = (
            url_split[url_split.index("cours") - 1] if "bourse" in r.url else "stock"
        )
        data["name"] = unicode_escape(name)
        data["url"] = r.url
        data["currency"] = (
            relevant_tag.find_all("span", class_='\\"c-faceplate__price-currency\\"')
            .pop()
            .get_text()
            .strip()
        )
        map_attributes = {
            "indice de référence": "referenceIndex",
            "catégorie morningstar": "morningstarCategory",
            "amChartData": "AssetsComposition",
        }
        # Init entries with null values
        for v in map_attributes.values():
            data[v] = None
        if "bourse" in r.url:
            additional_info = soup.find_all("p", class_='\\"c-list-info__heading')
            for i in additional_info:
                attr = map_attributes.get(
                    unicode_escape(i.get_text()).strip().lower(),
                    unicode_escape(i.get_text()).strip(),
                )
                for v in i.next_siblings:
                    v = unicode_escape(v.get_text()).strip()
                    if "?" in v or len(v) < 1:
                        continue
                    elif data.get(attr, None) is None:
                        data[attr] = v
                    elif isinstance(data[attr], str):
                        data[attr] = [data[attr]] + [v]
                    else:
                        data[attr].append(v)

        # Composition
        url_split.insert(-2, "composition")
        composition_request = requests.get("/".join(url_split))
        if composition_request.status_code == 200:
            soup = BeautifulSoup(
                json.dumps(composition_request.content.decode("utf-8")), "lxml"
            ).body
            data["assetsComposition"] = extract_chart_data(soup, '\\"portfolio\\"')
            # data['sectors'] = extract_chart_data(soup,'\\"sector\\"' )
        else:
            data["assetsComposition"] = [{"name": data["asset"], "value": 100}]
            # data['sectors'] = [{'name': unicode_escape([link for link in soup.select('a[c-list-info__value]')][0].get_text()),
            #                  'value':100}]
        last_dividende = soup.find_all("p", string=re.compile("dernier dividende"))
        data["lastDividende"] = {}
        if len(last_dividende) > 1:
            amount = False
            for p_tag in last_dividende:
                for sibling in p_tag.next_siblings:
                    if isinstance(sibling, Tag) and sibling.name == "p":
                        if sibling.attrs["class"] in [
                            ['\\"c-list-info__value'],
                            '\\"c-list-info__value',
                        ]:
                            if not amount:
                                data["lastDividende"]["amount"] = unicode_escape(
                                    sibling.get_text()
                                ).strip()
                                amount = True
                                continue
                            try:
                                data["lastDividende"]["date"] = datetime.strptime(
                                    unicode_escape(sibling.get_text()).strip(),
                                    "%d.%m.%y",
                                )
                            except ValueError as e:
                                print(e)
                                data["lastDividende"]["date"] = unicode_escape(
                                    sibling.get_text()
                                ).strip()

        data = {k: (v.strip() if isinstance(v, str) else v) for k, v in data.items()}
        return data
    except StopIteration as e:
        print(e)
        raise ValueError(
            f"{asset}: No asset found. Try with another name or the ISIN of your asset."
        )


def get_historical_data(bourso_ticker: str) -> pd.DataFrame:
    """Use the API of boursorama to get the historical quotes of the asset"""
    req = requests.get(
        f"https://www.boursorama.com/bourse/action/graph/ws/GetTicksEOD?symbol={bourso_ticker}&length=7300&period=0"
    )
    df = pd.DataFrame(req.json()["d"]["QuoteTab"])
    # convert to datetime object
    df["date"] = pd.to_datetime(df["d"], unit="D").dt.date
    # ensure to get all the dates since inception. to avoid missing values in charts
    start_date = df["date"].min()
    all_dates = {
        "date": [
            start_date + timedelta(days=x) for x in range((TODAY - start_date).days + 1)
        ]
    }
    date_df = pd.DataFrame.from_dict(all_dates)
    date_df["date"] = pd.to_datetime(date_df["date"]).dt.date
    # merge the two dateframes
    df = pd.merge(date_df, df, how="left", on="date")
    # forward fill missing values
    df = df.ffill()

    return df

if __name__ == '__main__':
    air_liquide = ['air liquide', 'FR0000120073']
    lvmh = ['mc', 'lvmh', 'FR0000121014']
    items = {Asset.from_boursorama(get_current_asset_data(asset)) for asset in air_liquide+lvmh}



#+end_src
* Portfolio class

- Aggregate financial data in an instance of Portfolio object
- Give stats (XIRR, quantity, dividends, quotes), charts about the assets of your portfolio/tracked assets
- Give stats of your overall portfolio.
- Three available periods of time for the XIRR: Year-to-Date (Ytd), last Year, since inception
** Code :noexport:
:properties:
:header-args:python: :tangle src/portfolio.py
:end:
#+begin_src python
from datetime import date
from math import floor
from pathlib import Path
from typing import Union

import duckdb
import pandas as pd
import srsly
from attrs import define, field
from icecream import ic
from pyxirr import xirr, xnpv
from src.data_extraction import (
    DATE_FORMAT,
    TODAY,
    Asset,
    compute_perf,
    get_current_asset_data,
    map_period_to_filter,
)


@define
class Portfolio:
    name: str
    jsonl_ptf_path: str = field(init=False)
    csv_ptf_path: str = field(init=False)
    dict_of_assets: dict = field(init=False)
    operations_df: pd.DataFrame = field(init=False)
    _assets_summary: pd.DataFrame = None
    _asset_values: pd.DataFrame = None
    _portfolio_summary: pd.DataFrame = None

    def __attrs_post_init__(self):
        self.jsonl_ptf_path = f"data/jsonl/{self.name}.jsonl"
        self.csv_ptf_path = f"data/operations/{self.name}.csv"
        self.dict_of_assets = (
            {
                a["isin"]: Asset.from_boursorama(get_current_asset_data(a["url"]))
                for a in srsly.read_jsonl(self.jsonl_ptf_path)
            }
            if Path(self.jsonl_ptf_path).is_file()
            else {}
        )
        self.operations_df = self.load_operations()
        # duckdb cannot request directly on class attribute
        distinct_isins = self.operations_df["isin"].unique()
        self.dict_of_assets.update(
            {
                isin: Asset.from_boursorama(get_current_asset_data(isin))
                for isin in distinct_isins
            }
        )

    def load_operations(self) -> pd.DataFrame:
        """Initialize or read a csv file to get a
        dataframe containing the operations"""
        db_exists = Path(self.csv_ptf_path).is_file()

        if not db_exists:

            operations = pd.DataFrame(
                {
                    column_name: []
                    for column_name in [
                        "name",
                        "isin",
                        "date",
                        "operation",
                        "quantity",
                        "value",
                        "fees",
                    ]
                }
            )

            operations = pd.DataFrame(
                {
                    column_name: []
                    for column_name in [
                        "name",
                        "isin",
                        "date",
                        "operation",
                        "quantity",
                        "value",
                        "fees",
                    ]
                }
            )
        else:
            operations = pd.read_csv(self.csv_ptf_path)
            operations["date"] = pd.to_datetime(operations["date"]).dt.strftime(
                DATE_FORMAT
            )
            operations = duckdb.sql(
                """
                select row_number() over(order by date, isin, name) as id,
                * from operations ORDER BY id, date, name, isin DESC """
            ).df()
        return operations

    @property
    def assets_summary(self) -> pd.DataFrame:
        """"""
        if self._assets_summary is None and len(self.operations_df) > 0 :
            df = self.operations_df.copy()
            assets = []
            for isin in df["isin"].unique():
                isin_df = duckdb.sql(
                    f"""
                select * from df where isin = '{isin}'
                order by date"""
                ).df()
                quantity, total_dividends, isin_df["cumulative_quantity"] = (
                    self.get_asset_quantity(isin_df)
                )

                cashflows_dict = {
                    period: self.get_cashflow_df(
                        isin_df,
                        self.dict_of_assets[isin].quotations[period],
                        period,
                        isin,
                    )
                    for period in ["ytd", f"{TODAY.year-1}", "inception"]
                }

                summary = {
                    "name": self.dict_of_assets[isin].name,
                    "isin": isin,
                    "asset": self.dict_of_assets[isin].asset,
                    "quantity": quantity,
                    "daily variation": self.dict_of_assets[isin].variation,
                    "currency": self.dict_of_assets[isin].currency,
                    "latest": self.dict_of_assets[isin].latest,
                    "total dividends": total_dividends,
                    "IRR ytd": self.compute_xirr_pv(
                        cashflows_dict["ytd"], period="ytd"
                    ),
                    f"IRR {TODAY.year-1}": self.compute_xirr_pv(
                        cashflows_dict[f"{TODAY.year-1}"], period=f"{TODAY.year-1}"
                    ),
                    "IRR since 1st buy": self.compute_xirr_pv(
                        cashflows_dict["inception"], period="inception"
                    ),
                    "Total invested amount": self.compute_xirr_pv(
                        cashflows_dict["inception"], period="inception", invested=True
                    ),
                    "Perf ytd": compute_perf(
                        self.dict_of_assets[isin].quotations["ytd"]
                    ),
                    f"Perf {TODAY.year-1}": compute_perf(
                        self.dict_of_assets[isin].quotations[f"{TODAY.year-1}"]
                    ),
                    "Perf 1m": compute_perf(
                        self.dict_of_assets[isin].quotations["1month"]
                    ),
                    "Perf 6m": compute_perf(
                        self.dict_of_assets[isin].quotations["6months"]
                    ),
                    "Perf 1y": compute_perf(
                        self.dict_of_assets[isin].quotations["1year"]
                    ),
                    "Perf 3y": compute_perf(
                        self.dict_of_assets[isin].quotations["3years"]
                    ),
                    "Perf 5y": compute_perf(
                        self.dict_of_assets[isin].quotations["5years"]
                    ),
                    "operations": isin_df,
                }
                summary["valuation"] = summary["quantity"] * summary["latest"]
                summary["Capital gain"] = (
                    summary["valuation"] - summary["Total invested amount"]
                )
                summary["Capital gain (%)"] = (
                    100
                    * (summary["valuation"] - summary["Total invested amount"])
                    / summary["Total invested amount"]
                )

                assets.append(summary)

            self._assets_summary = pd.DataFrame(assets)
            self._assets_summary["proportion (%)"] = round(
                100
                * self._assets_summary["valuation"]
                / self._assets_summary["valuation"].sum(),
                2,
            )
            # Keep only assets we currently own
            self._assets_summary = self._assets_summary.loc[
                self._assets_summary["valuation"] > 0
            ]
            # Reorder columns
            cols = list(self._assets_summary.columns)
            cols = cols[23:] + cols[0:12] + cols[20:23] + cols[12:20]
            self._assets_summary = self._assets_summary[cols]
        return self._assets_summary

    def get_asset_quantity(self, df: pd.DataFrame, limit_day: date = TODAY):
        """Get the total number of parts of an asset and the total dividends earned"""
        quantity = 0
        total_dividends = 0
        tracking = []
        for op in df.itertuples(index=False, name="Row"):
            if op.date > str(limit_day):
                break
            elif op.operation == "Buy":
                quantity += op.quantity
            elif op.operation == "Sell":
                quantity -= op.quantity
            elif op.operation == "Split":
                quantity = floor(op.value * quantity)
            elif op.operation == "Dividend":
                total_dividends += quantity * op.value
            tracking.append(quantity)
        return quantity, total_dividends, tracking

    def get_cashflow_df(
        self,
        operations: pd.DataFrame,
        quotations: pd.DataFrame,
        period: str = "inception",
        isin: Union[str, None] = None,
    ) -> pd.DataFrame:
        if isin:
            cashflows_df = duckdb.sql(
                f"""
                with first_last_quotations as (
                select * from (select
                date,
                c as value,
                row_number() over(order by date) as rn,
                count(*) over() as total_count
                from quotations
                order by date)
                full join operations
                using (date, value)
                where rn = 1 or rn = total_count or rn is null
                order by date),

                lag_df as (select *,
                COALESCE(quantity, lag(quantity) over(order by date)) as quantity_,
                COALESCE(cumulative_quantity,
                lag(cumulative_quantity) over(order by date)) as cumulative_quantity_
                from first_last_quotations flq

                order by date)

                select date, operation, quantity_ as quantity, value,
                (CASE
                WHEN operation = 'Buy' THEN -quantity_*value
                WHEN operation = 'Split' THEN 0
                WHEN operation IS NULL and rn=1 THEN -COALESCE(cumulative_quantity_,
                0)*value
                WHEN operation IS NULL and rn!=1 THEN COALESCE(cumulative_quantity_,
                lag(cumulative_quantity_) over(order by date))*value
                ELSE quantity_*value
                END) as cashflow
                from lag_df
                {map_period_to_filter.get(period, '')}

                """
            ).df()
        else:
            # Whole portfolio
            cashflows_df = duckdb.sql(
                f"""
                    with first_last_quotations as (
                    select date,
                    (case when rn = 1 then -v
                    when rn = total_count or rn is null then v end) as cashflow
                    from (select
                    cast(date as DATE) date,
                    sum(value) as v,
                    row_number() over(order by date) as rn,
                    count(*) over() as total_count
                    from quotations
                    {map_period_to_filter.get(period, '')}
                    group by date)
                    where rn = 1 or rn = total_count or rn is null
                    order by date),
                    cashflows as (
                    select date,
                    (CASE
                    WHEN operation = 'Buy' THEN -quantity*value
                    WHEN operation = 'Sell' THEN quantity*value
                    WHEN operation = 'Dividend' THEN cumulative_quantity * value
                    END
                    ) as cashflow from operations
                    where cashflow is not null)

                    select date, cashflow from cashflows
                    full outer join first_last_quotations
                    using (date, cashflow)
                    {map_period_to_filter.get(period, '')}
                    order by date
                    """
            ).df()

        return cashflows_df

    def compute_xirr_pv(
        self,
        cashflows_df: pd.DataFrame,
        period: str = "inception",
        invested: bool = False,
        test=False,
    ):
        try:
            if invested:
                invested_amount = round(-(cashflows_df["cashflow"].iloc[:-1].sum()), 2)
                return invested_amount
            else:
                if period == "ytd":
                    current_year = 2024 if test else TODAY.year
                    cashflows_df.at[len(cashflows_df.index) - 1, "date"] = date(
                        year=current_year, month=12, day=31
                    )
            irr = xirr(cashflows_df["date"], cashflows_df["cashflow"]) * 100
            return irr
        except Exception as e:
            print(e)
            return 0

    @property
    def asset_values(self):
        """"""
        if self._asset_values is None and len(self.operations_df)>0:
            isins = self.operations_df["isin"].unique()
            all_quotations_df = []
            for isin in isins:
                isin_df = self.dict_of_assets[isin].quotations["inception"].copy()
                all_quotations_df.append(
                    duckdb.sql(
                        f""" select *, '{self.dict_of_assets[isin].name}' as name from isin_df
                """
                    ).df()
                )

            all_quotations_df = pd.concat(all_quotations_df)
            # can't join on operation_df, because we need cumulative quantities.
            cum_quantities_df = pd.concat(
                [df for df in self.assets_summary["operations"]]
            )
            all_quotations_df["date"] = pd.to_datetime(
                all_quotations_df["date"]
            ).dt.date

            # Fill null value with last non null value for each asset
            self._asset_values = duckdb.sql(
                """
                with grouped as (
                select date, name, c,
                cumulative_quantity,
                count(cumulative_quantity) over(partition by name order by date) as grouper
                from all_quotations_df aqdf
                left join cum_quantities_df cqdf
                using(date, name)
                where date >= (select min(date) from cum_quantities_df)
                order by date
                )
                select * from (select date, name,
                max(cumulative_quantity)
                over(partition by name, grouper
                order by date)*c as value
                from grouped
                order by date)
                """
            ).df()
            self._asset_values["date"] = pd.to_datetime(
                self._asset_values["date"]
            ).dt.date
        return self._asset_values

    @property
    def portfolio_summary(self):
        """"""
        if self._portfolio_summary is None and len(self.operations_df) > 0:
            cum_quantities_df = pd.concat(
                [df for df in self.assets_summary["operations"]]
            )
            cashflows_dict = {
                period: self.get_cashflow_df(
                    cum_quantities_df,
                    self.asset_values,
                    period,
                )
                for period in ["ytd", f"{TODAY.year-1}", "inception"]
            }
            ptf_summary = {
                "Lines number": len(self.assets_summary),
                "valuation": self.assets_summary["valuation"].sum(),
                "total earned dividends": self.assets_summary["total dividends"].sum(),
                "Capital gain": self.assets_summary["Capital gain"].sum(),
                "Total invested amount": self.assets_summary[
                    "Total invested amount"
                ].sum(),
                "IRR ytd": self.compute_xirr_pv(cashflows_dict["ytd"], period="ytd"),
                f"IRR {TODAY.year-1}": self.compute_xirr_pv(
                    cashflows_dict[f"{TODAY.year-1}"], period=f"{TODAY.year-1}"
                ),
                "IRR since 1st buy": self.compute_xirr_pv(
                    cashflows_dict["inception"], period="inception"
                ),
            }
            ptf_summary["Capital gain (%)"] = (
                100
                * (ptf_summary["valuation"] - ptf_summary["Total invested amount"])
                / ptf_summary["Total invested amount"]
            )
            self._portfolio_summary = pd.DataFrame([ptf_summary])
        return self._portfolio_summary


#+end_src
* Streamlit
- Use streamlit to run the webapp
- run it by opening a terminal at the project locationby typing ~streamlit run app.py~
** Code :noexport:
:properties:
:header-args:python: :tangle app.py
:end:

#+begin_src python
from itertools import chain
from pathlib import Path
from typing import Iterable

import duckdb
import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import srsly
import streamlit as st
from attrs import asdict
from attrs.filters import exclude
from icecream import ic

# sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from src.data_extraction import (
    Asset,
    compute_perf,
    date_to_str,
    get_current_asset_data,
)
from src.portfolio import Portfolio

# page config
st.set_page_config(
    page_title="Asset visualizer", layout="wide", initial_sidebar_state="expanded"
)
st.title("Asset visualizer")

# Create data/json, data/parquet if they do not exist
for save_path in ["data/jsonl", "data/operations"]:
    Path(save_path).mkdir(parents=True, exist_ok=True)

# Portfolio name, accept user input
ptf_name = st.text_input(
    "Name of the portfolio (This name will be used the save and load your portfolio.)",
    st.session_state.get("ptf_name", "MyPortfolio"),
    placeholder="MyPortfolio",
    key="ptf_name",
)

# Load it
portfolio = Portfolio(ptf_name)
st.session_state["name_isin"] = {
    (a.name, a.isin) for a in portfolio.dict_of_assets.values()
}


def plot_piechart(data: Iterable, cat_name: str = "name", value: str = "value"):
    """Extract varible names and their values.
    Returns a pie chart."""
    categories = []
    values = []
    for d in data:
        categories.append(d[cat_name])
        values.append(d[value])
    fig = go.Figure(data=[go.Pie(labels=categories, values=values)])
    return fig


def ptf_piechart(iter_of_dicts: Iterable):
    """Pie chart for portfolio"""
    d = {}
    for i, dict_ in enumerate(iter_of_dicts):
        d[dict_["name"]] = d.get(dict_["name"], 0) + dict_["value"]
    [*categories], [*values] = list(zip(*d.items()))
    values = np.array(values)
    fig = go.Figure(data=[go.Pie(labels=categories, values=values / (i + 1))])
    return fig


def plot_historical_chart(df: pd.DataFrame, name: str, isin: str):
    """Plot historical chart"""
    fig = px.line(df, x="date", y="c", title=f"{name} - {isin}")
    return fig


# Sidebar
with st.form("sidebar"):
    with st.sidebar:
        # User input for isin
        asset = st.text_input(
            "Enter an ISIN. You may also enter a name or a ticker, but you might get some errors."
            "\nPrefilled with MC, the ticker of LVMH stock.",
            value=st.session_state.get("last_asset", "MC"),
            placeholder="ISIN, Ticker.",
            key="last_asset",
        )
        adding_to_portfolio = st.checkbox("Add to your portfolio", True)
        submitted = st.form_submit_button("Submit")
        if submitted:
            # scrap first result associated to the user input
            st.write(f"Asset: {asset}")
            asset_obj = Asset.from_boursorama(get_current_asset_data(asset))
            st.header(f"Name: {asset_obj.name}")
            asset_as_dict = asdict(asset_obj, filter=exclude("_quotations"))
            asset_as_dict["tradeDate"] = date_to_str(asset_as_dict["tradeDate"])
            if len(asset_as_dict["lastDividende"]) > 0:
                asset_as_dict["lastDividende"]["date"] = date_to_str(
                    asset_as_dict["lastDividende"]["date"]
                )
            # display the data
            st.dataframe(
                asset_as_dict,
                column_config={0: "property", 1: "value"},
                use_container_width=True,
            )

            asset_comp, historic_chart = st.tabs(
                ["Asset composition", "Historical prices"]
            )

            with asset_comp:
                # Plot asset composition
                st.subheader("Asset composition")
                asset_comp_chart = plot_piechart(
                    asset_as_dict["assetsComposition"], "name", "value"
                )
                st.plotly_chart(asset_comp_chart, use_container_width=True)

            with historic_chart:
                # plot historical chart
                st.subheader(f"Historical prices {asset_as_dict['currency']}")
                perf_dict = pd.DataFrame(
                    [
                        {
                            key: compute_perf(asset_obj.quotations[key])
                            for key in asset_obj.quotations
                        }
                    ]
                ).T
                perf_dict.columns = ["Performance"]
                st.dataframe(perf_dict)
                st.write(
                    "You can view the chart in full screen and zoom in the period by selecting the wanted period."
                )
                st.plotly_chart(
                    plot_historical_chart(
                        asset_obj.quotations["inception"],
                        asset_as_dict["name"],
                        asset_as_dict["isin"],
                    )
                )

# Body
operations_col, details_col = st.tabs(["Portfolio Operations", "Portfolio details"])

## Portfolio tab
with details_col:
    if submitted and adding_to_portfolio:
        # Add to dict of assets the new asset
        portfolio.dict_of_assets[asset_obj.isin] = asset_obj
        st.session_state["name_isin"].add((asset_obj.isin, asset_obj.name))
        # Update jsonl
        srsly.write_jsonl(
            portfolio.jsonl_ptf_path,
            [
                asdict(a, filter=exclude("_quotations"))
                for a in portfolio.dict_of_assets.values()
            ],
        )

    with st.expander("Followed assets"):
        # summary of followed assets in an expandable window
        ptf_df = pd.DataFrame(
            [
                {
                    k: v
                    for k, v in asdict(a).items()
                    if k
                    not in [
                        "tradeDate",
                        "assetsComposition",
                        "url",
                        "referenceIndex",
                        "morningstarCategory",
                    ]
                }
                for a in portfolio.dict_of_assets.values()
            ]
        )

        ptf_df.insert(0, "in_ptf", True)
        with st.form("update_assets"):
            # To modify the followed assets
            ptf_df = st.data_editor(
                ptf_df,
                column_config={
                    "in_ptf": st.column_config.CheckboxColumn(
                        "In portfolio?",
                        help="Select your current assets.",
                        default=True,
                    ),
                    "_quotations": None,
                },
                disabled=[column for column in ptf_df.columns if column != "in_ptf"],
                hide_index=True,
            )
            update_assets = st.form_submit_button("Update assets")
            if update_assets:
                keep_isin = duckdb.sql(
                    """SELECT isin from ptf_df where in_ptf='True'"""
                ).fetchall()
                srsly.write_jsonl(
                    portfolio.jsonl_ptf_path,
                    [
                        asdict(portfolio.dict_of_assets[a])
                        for a in portfolio.dict_of_assets
                        if a in set(chain.from_iterable(keep_isin))
                    ],
                )
                st.rerun()

    # If there are some operations, display summary and stats about the portfolio
    if len(portfolio.operations_df["isin"]) > 0:
        # Summary by asset
        st.subheader("Portfolio lines")
        st.dataframe(
            portfolio.assets_summary.round(2),
            hide_index=True,
            column_config={"operations": None},
        )

        # Portfolio summary
        st.subheader("Overall stats")
        st.dataframe(portfolio.portfolio_summary.round(2), hide_index=True)

        # Historical chart
        filled_area_plot = px.area(
            portfolio.asset_values, x="date", y="value", color="name"
        )
        st.subheader("Historical records")
        st.plotly_chart(filled_area_plot, use_container_width=True)

        # Map French asset terminology to their English counterpart
        asset_types = {
            "actions": "stock",
            "obligations": "bond",
            "immobilier": "real estate",
            "matières premières": "commodities",
            "liquidités": "cash",
            "autres": "other",
        }
        total_assets_comp = [
            {
                "name": asset_types.get(d["name"].lower(), d["name"]),
                "value": d["value"] * k,
            }
            for i, (a, k) in enumerate(
                zip(
                    portfolio.assets_summary["isin"].tolist(),
                    portfolio.assets_summary["proportion (%)"].tolist(),
                )
            )
            for d in portfolio.dict_of_assets[a].assetsComposition
        ]

        ptf_asset_comp, ptf_asset_proportion = st.columns(2)
        with ptf_asset_comp:
            # Asset types repartition
            st.subheader("Portfolio asset repartition")
            ptf_asset_comp_chart = ptf_piechart(total_assets_comp)
            st.plotly_chart(ptf_asset_comp_chart, use_container_width=True)

        with ptf_asset_proportion:
            # Chart of assets
            st.subheader("Proportion of each asset in your portfolio")
            proportion_fig = px.pie(
                portfolio.assets_summary,
                values="valuation",
                names="name",
                title="Proportion of each asset in your portfolio",
            )
            st.plotly_chart(proportion_fig, use_container_width=True)


with operations_col:
    st.subheader("Portfolio operations")
    st.dataframe(portfolio.operations_df, hide_index=True)

    # Operation tabs
    add_row, del_row = st.tabs(["Add operation", "Remove operation"])
    # Add operation
    with add_row:
        with st.empty().container():
            operation_type = st.selectbox(
                "Operation type",
                ("Buy", "Sell", "Dividend", "Split"),
                index=None,
                placeholder="Select your operation type.",
                key="operation_type_add",
            )
            operation_date = st.date_input(
                "Date operation", "today", format="YYYY-MM-DD", key="operation_date_buy"
            )
            operation_on_asset = st.selectbox(
                "The asset to perform the operation.",
                st.session_state["name_isin"],
                index=None,
                placeholder="Select the asset.",
                key="asset_operation_add",
            )
            argA, argB, taxes_fees = None, None, 0
            if st.session_state.get("operation_type_add", None) not in [
                "Split",
                "Interest",
            ]:
                if operation_type in ["Buy", "Sell"]:
                    taxes_fees = st.number_input("Taxes/Fees", min_value=0.00)
                    if operation_type == "Buy":
                        argB = st.number_input("Quantity", value=1.0, min_value=0.001)
                        argA = st.number_input("Price", min_value=0.00)
                    else:  # sell
                        # Do not allow to sell more assets that we own
                        try:
                            copy_operations_df = portfolio.operations_df.copy()
                            asset_operations = duckdb.sql(
                                f"""select operation, sum(quantity) as sum_qty
                            from copy_operations_df
                            where name='{st.session_state["asset_operation_add"][0]}'
                            and isin='{st.session_state["asset_operation_add"][1]}'
                            group by operation"""
                            ).fetchall()
                            asset_operations = {
                                op: value for (op, value) in asset_operations
                            }

                            argB = st.number_input(
                                "Quantity",
                                value=1.0,
                                min_value=0.0,
                                max_value=asset_operations.get("Buy", 0)
                                - asset_operations.get("Sell", 0),
                            )
                            argA = st.number_input("Price", min_value=0.00)

                        except Exception as e:
                            print(e)
                            # Cannot sell assets we do not own.
                            st.write("You cannot sell assets you do not own.")
                            # Disable add operation button
                            st.session_state["invalid_operation"] = 1
                elif operation_type == "Dividend":
                    argA = st.number_input("Dividend value", min_value=0.01)

            elif st.session_state.get("operation_type_add", None) == "Split":
                argA = st.text_input(
                    "Split ratio",
                    placeholder='Enter the split ratio, e.g. "11:10" or "2:1"',
                )
                if argA:
                    # Check the ratio is valid
                    after, before = argA.strip().split(":")
                    if not after.isdecimal() or not before.isdecimal():
                        raise ValueError(
                            "You must enter a valid split ratio,"
                            " two integer numbers separated by a colon(:)."
                        )
                    argA = int(after) / int(before)
            # Check all arguments are filled to enable add operation button
            if all([operation_on_asset is not None, operation_type is not None]):
                st.session_state["invalid_operation"] = 0

            # Append operation to csv
            if st.button(
                "Add operation", disabled=st.session_state.get("invalid_operation", 1)
            ):
                portfolio.operations_df.loc[len(portfolio.operations_df.operation)] = {
                    "name": operation_on_asset[0],
                    "isin": operation_on_asset[1],
                    "date": operation_date.isoformat(),
                    "operation": operation_type,
                    "quantity": argB,
                    "value": argA,
                    "fees": taxes_fees,
                }
                portfolio.operations_df.to_csv(
                    portfolio.csv_ptf_path,
                    index=False,
                    columns=[
                        col
                        for col in portfolio.operations_df.columns
                        if not col.startswith("id")
                    ],
                )
                # elif operation_type in ['Dividend', 'Split']:

                # duckdb.sql(f'COPY operations TO {csv_ptf_path}')
                st.rerun()

    # Delete row
    with del_row:
        with st.form("delete_row"):
            try:
                row_number = st.number_input(
                    "Row number",
                    min_value=1,
                    max_value=len(portfolio.operations_df.operation),
                    placeholder="Row number to remove",
                )
            except Exception as e:
                # Cannot remove an operation if there is no operation registered.
                print(e)
                st.write("Please add an operation before trying to remove one.")
            delete_row = st.form_submit_button("Delete row")
            if delete_row:
                # Keep all the operations except the n_th
                duckdb.sql(
                    f"""
                 WITH row_nb_table AS (
                 select row_number() over(order by date, isin, name) as id,
                 ,* from '{portfolio.csv_ptf_path}'
                 ORDER BY  date, name, isin DESC
                 )
                 Select
                 rnt.name,
                 rnt.isin,
                 rnt.date,
                 rnt.operation,
                 rnt.quantity,
                 rnt.value
                 rnt.fees
                 from row_nb_table rnt
                 Left JOIN '{portfolio.csv_ptf_path}'
                 using (isin, date, operation, quantity,value,fees)
                 where rnt.id != {row_number}
                 """
                ).write_csv(portfolio.csv_ptf_path)
                st.rerun()
#+end_src

* Tests
To run tests: run in a terminal the following ~python tests/unit_tests.py~
#+begin_src bash

#+end_src
** Code :noexport:
#+begin_src python :tangle tests/unit_tests.py
import os
import sys
import time
import unittest

import pandas as pd

sys.path.append(os.path.join(os.path.dirname(__file__), ".."))
from src.data_extraction import Asset, get_current_asset_data
from src.portfolio import Portfolio


# Scrapping
class TestAsset(unittest.TestCase):
    """Ensure the scraped data is correct"""

    def test_stock(self):
        """Stock: air liquide"""
        for search in ["air liquide", "AI", "FR0000120073"]:
            with self.subTest(i=search):
                AirLiquide = Asset.from_boursorama(get_current_asset_data(search))
                self.assertEqual(AirLiquide.asset, "stock")
                self.assertEqual(AirLiquide.isin, "FR0000120073")
                self.assertEqual(AirLiquide.currency, "EUR")
                self.assertEqual(AirLiquide.name, "AIR LIQUIDE")
                self.assertEqual(AirLiquide.symbol, "1rPAI")
                self.assertEqual(
                    AirLiquide.url, "https://www.boursorama.com/cours/1rPAI/"
                )
                self.assertGreaterEqual(AirLiquide.latest, 0)
                self.assertIsNone(AirLiquide.referenceIndex)
                self.assertIsNone(AirLiquide.morningstarCategory)
            time.sleep(1)

    def test_tracker(self):
        """Tracker: cw8"""
        for search in ["LU1681043599", "CW8"]:
            with self.subTest(i=search):
                cw8 = Asset.from_boursorama(get_current_asset_data(search))
                self.assertEqual(cw8.asset, "trackers")
                self.assertEqual(cw8.isin, "LU1681043599")
                self.assertEqual(cw8.currency, "EUR")
                self.assertEqual(cw8.name, "AMUNDI MSCI WORLD UCITS ETF - EUR")
                self.assertEqual(cw8.symbol, "1rTCW8")
                self.assertEqual(
                    cw8.url, "https://www.boursorama.com/bourse/trackers/cours/1rTCW8/"
                )
                self.assertGreaterEqual(cw8.latest, 0)
                self.assertEqual(cw8.referenceIndex, "MSCI World")
                self.assertEqual(
                    cw8.morningstarCategory, "Actions International Gdes Cap. Mixte"
                )
            time.sleep(1)

    def test_opcvm(self):
        """OPCVM: Réserve Ecureuil C"""
        for search in ["FR0010177378"]:
            with self.subTest(i=search):
                ecureuil = Asset.from_boursorama(get_current_asset_data(search))
                self.assertEqual(ecureuil.asset, "opcvm")
                self.assertEqual(ecureuil.isin, "FR0010177378")
                self.assertEqual(ecureuil.currency, "EUR")
                self.assertEqual(ecureuil.name, "Réserve Ecureuil C")
                self.assertEqual(ecureuil.symbol, "MP-184677")
                self.assertEqual(
                    ecureuil.url,
                    "https://www.boursorama.com/bourse/opcvm/cours/MP-184677/",
                )
                self.assertGreaterEqual(ecureuil.latest, 0)
                self.assertEqual(ecureuil.morningstarCategory, "Swap EONIA PEA")
                self.assertIsNone(ecureuil.referenceIndex)
            time.sleep(1)


class TestPortfolio(unittest.TestCase):
    """Test code with empty and non-empty portfolio"""

    def test_non_empty_portfolio(self):
        """Test code with non-empty portfolio"""
        non_empty_ptf = Portfolio("unit_tests_ptf")

        self.assertEqual(len(non_empty_ptf.operations_df), 16)
        self.assertEqual(len(non_empty_ptf.dict_of_assets), 3)

        total_dividends = pd.DataFrame(
            {
                "isin": ["FR0011869353", "FR0000120073", "FR0010177378"],
                "asset": ["trackers", "stock", "opcvm"],
                "quantity": [200.0, 65.0, 67.0],
            },
            index=range(3),
        )
        self.assertEqual(
            non_empty_ptf.assets_summary.loc[:, ["isin", "asset", "quantity"]].equals(
                total_dividends
            ),
            True,
        )
        self.assertEqual(non_empty_ptf.portfolio_summary.at[0, "Lines number"], 3)
        self.assertEqual(
            round(non_empty_ptf.portfolio_summary.at[0, "Total invested amount"], 2),
            24578.51,
        )
        # Unit test: IRR, asset: Air liquide
        cashflows_df = pd.read_csv("tests/tests_cashflows.csv")
        cashflows_df = cashflows_df.iloc[:-1, :].round(2)
        cum_quantities_df = pd.concat(
            df for df in non_empty_ptf.assets_summary["operations"]
        )
        test_cashflows_df = non_empty_ptf.get_cashflow_df(
            cum_quantities_df, non_empty_ptf.asset_values, "inception"
        ).iloc[:-1, :]
        self.assertEqual(
            cashflows_df.equals(test_cashflows_df.round(2)),
            True,
        )

    def test_empty_ptf(self):
        """Test code with empty, non-existant portfolio"""
        empty_ptf = Portfolio("empty_unit_tests_ptf")
        self.assertFalse(len(empty_ptf.operations_df) > 0)
        self.assertFalse(len(empty_ptf.dict_of_assets) > 0)
        self.assertIsNone(empty_ptf.assets_summary)
        self.assertIsNone(empty_ptf.portfolio_summary)
        self.assertIsNone(empty_ptf.asset_values)


if __name__ == "__main__":
    unittest.main()
#+end_src
* Next steps
- Add a way to configure data for SCPIs
- Add manual assets, e.g. Deposit account
- Import operations from csv, pdf
